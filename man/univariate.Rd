% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/basic.R
\name{univariate}
\alias{Max}
\alias{Mean}
\alias{Median}
\alias{Min}
\alias{Sum}
\alias{univariate}
\title{Univariate Statistics}
\usage{
Sum(data, inputs, outputs)

Mean(data, inputs = AUTO, outputs = AUTO)

Min(data, inputs = AUTO, outputs = AUTO)

Max(data, inputs = AUTO, outputs = AUTO)

Median(data, inputs = AUTO, outputs = result, number.bins = 1000,
  sort.threshold = 1000)
}
\arguments{
\item{data}{A \code{\link{waypoint}}.}

\item{outputs}{The usual way to specify the outputs. If both this and names
for the \code{inputs} are given, a warning is given and \code{outputs} is
used.}

\item{number.bins}{The number of bins to use in the binning algorithm.}

\item{sort.threshold}{The maximum number of items on which to manually sort.}

\item{input}{A named list of expressions, with the names being used as the
  corresponding outputs. These expressions are outputted in addition to those
  used to specify the extremities.

  If no name is given and the corresponding  expression is simply an
  attribute, then said attribute is used as the name. Otherwise an error is
  thrown, as there is no reason to include an extra input if corresponding
  output column cannot be referenced later.}
}
\value{
A \code{\link{waypoint}} with a single row. See \sQuote{details} for
  more information.
}
\description{
These GLAs compute various univariate statistics separately for each input.
}
\details{
The result of each GLA is a waypoint with one column per input and a single
row whose value is the specified univariate statistic for the corresponding
expression.

With the exception of finding the median, all of these aggregates are fairly
straightforward, require \eqn{O(k)} space, and run in \eqn{O(n \cdot k)}
time, where \eqn{k} is the number of inputs and \eqn{n} is the number of
tuples.

The median algorithm relies on a iterative binning algorithm, based on the
Tibshirani paper. This algorithm requires two parameters: the number of bins
to use (\eqn{b}) and the threshold at which to sort (\eqn{t}). During the
first iteration, the range of the input is found. This interval is then split
into \eqn{b} equal parts. Each input is then sorted into bins and the bin
that must contain the median is then sub-divided into \eqn{b} equal parts.
This recursive sub-division continues until less than \eqn{t} elements are in
a bin that contains the median. These elements are then sorted and the median
is outputted. As such, this algorithm requires \eqn{O(k \cdot b)} spaces and
runs in \eqn{O(k \cdot (n \cdot \log_b n + t \log t))} time.
}
\author{
Jon Claus, <jonterainsights@gmail.com>, Tera Insights, LLC.
}
\references{
href{http://www.stat.cmu.edu/~ryantibs/papers/median.pdf}{Tibshirani} for
details regarding the binning algorithm.
}

